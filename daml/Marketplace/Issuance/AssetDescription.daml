module Marketplace.Issuance.AssetDescription where
-- Consider merging into DA.Finance.Types.Asset

import DA.Finance.Types (Account, Id)
import DA.Next.Set (Set)
import ContingentClaims.Claim.Serializable (Claim(..))
import ContingentClaims.Observation (Observation(..))

type T = AssetDescription
type Claims = Claim Date Id
type Version = Int

deriving instance Ord a => Ord (Observation Date a)
deriving instance Ord (Claim Date Id)

template AssetDescription
  with
    assetId: Id
    -- ^ This is the master record for the asset, and has embedded it's unique identifier
    description: Text
    -- ^ Short description of the asset, mainly for display purposes
    issuer: Party
    -- ^ The counterparty for any @claims@
    claims: Claims
    -- ^ Rights and obligations of the holder (and issuer)
    safekeepingAccount: Account
    -- ^ Source account used for issuing the security and any subsequent corporate actions, e.g. paying out a coupon.
    -- terms: Text
    -- ^ Any further contract terms not captured in @claims@; typically a URI.
    -- authorized: Decimal
    -- ^ Number of shares/contracts authorized for issuance
    -- issued: Decimal
    -- ^ Number of shares/contracts already issued for trading
    -- issuePrice: (Decimal, Asset)
    -- ^ The price & currency of the *initial* offer.
    indexReference: ContractId Index
    observers : Set Party
  where
    signatory assetId.signatories <> safekeepingAccount.id.signatories
    observer observers

    key assetId : Id
    maintainer key.signatories

-- Used to do a reverse lookup of the version # given the claims (passed-in from the API)
template Index
  with
    assetId: Id
    claims: Claims
  where
    signatory assetId.signatories
    key (assetId.signatories, assetId.label, claims) : (Set Party, Text, Claims)
    maintainer key._1
